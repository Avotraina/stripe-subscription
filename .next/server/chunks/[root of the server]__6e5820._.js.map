{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/avotraina/projetcts/bun/blog-generator/app/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst prismaClientSingleton = () => {\n  return new PrismaClient()\n}\n\ndeclare const globalThis: {\n  prismaGlobal: ReturnType<typeof prismaClientSingleton>;\n} & typeof global;\n\nconst prisma = globalThis.prismaGlobal ?? prismaClientSingleton()\n\nexport default prisma\n\nif (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,wBAAwB;IAC5B,OAAO,IAAI,2GAAA,CAAA,eAAY;AACzB;AAMA,MAAM,SAAS,WAAW,YAAY,IAAI;uCAE3B;AAEf,wCAA2C,WAAW,YAAY,GAAG"}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///home/avotraina/projetcts/bun/blog-generator/app/lib/stripe.ts"],"sourcesContent":["import Stripe from \"stripe\";\n\nexport const stripe = new Stripe(`${process.env.NEXT_PUBLIC_STRIPE_SECRET_KEY}` ?? \"\", {\n    apiVersion: \"2024-11-20.acacia\",\n    typescript: true,\n});"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,SAAS,IAAI,wJAAA,CAAA,UAAM,CAAC,oJAA8C,IAAI,IAAI;IACnF,YAAY;IACZ,YAAY;AAChB"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///home/avotraina/projetcts/bun/blog-generator/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import prisma from \"@/app/lib/db\";\nimport NextAuth, { AuthOptions } from \"next-auth\";\nimport KeycloakProvider from \"next-auth/providers/keycloak\";\nimport { stripe } from \"@/app/lib/stripe\";\n\n\nconst keycloak = KeycloakProvider({\n    clientId: `${process.env.KEYCLOAK_ID}`,\n    clientSecret: `${process.env.KEYCLOAK_SECRET}`,\n    issuer: `${process.env.KEYCLOAK_ISSUER}`,\n});\n\nexport const authOptions: AuthOptions = {\n    providers: [\n        keycloak\n    ],\n    secret: process.env.AUTH_SECRET,\n    callbacks: {\n        async signIn({ user, account, profile }) {\n\n            const userId = profile?.sub;\n            const email = profile?.email as string;\n            const name = profile?.name;\n\n            let stripeCustomerId = undefined;\n\n            const dbUser = await prisma.user.findFirst({\n                where: {\n                    keycloakUserId: profile?.sub\n                }\n            });\n\n            // if (dbUser?.stripeCustomerId) {\n\n            // }\n\n            \n\n            \n\n            try {\n\n                // if (!dbUser?.stripeCustomerId) {\n                //     const stripeCustomer = await stripe.customers.create({\n                //         email,\n                //         name: name ?? undefined,\n    \n                //     });\n\n                //     stripeCustomerId = stripeCustomer.id;\n                //     // const stripeCustomerExist = await stripe.customers.retrieve(dbUser?.stripeCustomerId as string);\n                // }\n\n\n                await prisma.user.upsert({\n                    where: { email: profile?.email },\n                    update: {\n                        keycloakUserId: profile?.sub,\n                        email: profile?.email,\n                        fullname: profile?.name,\n                        image: profile?.image,\n                        stripeCustomerId: dbUser?.stripeCustomerId ?? stripeCustomerId\n                    },\n                    create: {\n                        keycloakUserId: profile?.sub as string,\n                        email: profile?.email,\n                        fullname: profile?.name,\n                        image: profile?.image,\n                        stripeCustomerId: dbUser?.stripeCustomerId ?? stripeCustomerId\n\n                    },\n                });\n\n                return true;\n            } catch (error) {\n                return false;\n            }\n\n        },\n        async jwt({ token, account, profile }) {\n            if (account) {\n                token.id_token = account.id_token; // Include id_token in the token\n            }\n\n            if (account) {\n                token = { ...token, access_token: account.access_token };\n                token.exp = account.expires_at;\n                token.id_token = account.id_token ?? '';\n            }\n            return token;\n        },\n        async session({ session, token, user }) {\n            if (session) {\n                session.access_token = token.access_token as string;\n                session.user.id = token.sub\n                session.user.keyCloakUserId = token.sub\n                // session.user = await getUserInfo(session.access_token);\n            }\n            return {\n                ...session,\n                token: token,\n            };\n        },\n    },\n    pages: {\n        signIn: \"/dashboard\"\n    },\n    session: {\n        strategy: \"jwt\"\n    },\n    events: {\n        async signOut({ token }) {\n            const { id_token } = token;\n            console.log('ROUTE')\n\n            try {\n                const params = new URLSearchParams();\n                params.append('id_token_hint', id_token as string);\n\n                await fetch(`${keycloak?.options?.issuer}/protocol/openid-connect/logout?${params.toString()}`);\n                if (typeof window !== 'undefined') window.location.href = '/login';\n\n            } catch (error) {\n                console.error('Unable to perform post-logout handshake');\n            }\n\n        },\n    }\n}\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST }"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;AAIA,MAAM,WAAW,CAAA,GAAA,uJAAA,CAAA,UAAgB,AAAD,EAAE;IAC9B,UAAU,GAAG,QAAQ,GAAG,CAAC,WAAW,EAAE;IACtC,cAAc,GAAG,QAAQ,GAAG,CAAC,eAAe,EAAE;IAC9C,QAAQ,GAAG,QAAQ,GAAG,CAAC,eAAe,EAAE;AAC5C;AAEO,MAAM,cAA2B;IACpC,WAAW;QACP;KACH;IACD,QAAQ,QAAQ,GAAG,CAAC,WAAW;IAC/B,WAAW;QACP,MAAM,QAAO,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YAEnC,MAAM,SAAS,SAAS;YACxB,MAAM,QAAQ,SAAS;YACvB,MAAM,OAAO,SAAS;YAEtB,IAAI,mBAAmB;YAEvB,MAAM,SAAS,MAAM,kHAAA,CAAA,UAAM,CAAC,IAAI,CAAC,SAAS,CAAC;gBACvC,OAAO;oBACH,gBAAgB,SAAS;gBAC7B;YACJ;YAEA,kCAAkC;YAElC,IAAI;YAMJ,IAAI;gBAEA,mCAAmC;gBACnC,6DAA6D;gBAC7D,iBAAiB;gBACjB,mCAAmC;gBAEnC,UAAU;gBAEV,4CAA4C;gBAC5C,0GAA0G;gBAC1G,IAAI;gBAGJ,MAAM,kHAAA,CAAA,UAAM,CAAC,IAAI,CAAC,MAAM,CAAC;oBACrB,OAAO;wBAAE,OAAO,SAAS;oBAAM;oBAC/B,QAAQ;wBACJ,gBAAgB,SAAS;wBACzB,OAAO,SAAS;wBAChB,UAAU,SAAS;wBACnB,OAAO,SAAS;wBAChB,kBAAkB,QAAQ,oBAAoB;oBAClD;oBACA,QAAQ;wBACJ,gBAAgB,SAAS;wBACzB,OAAO,SAAS;wBAChB,UAAU,SAAS;wBACnB,OAAO,SAAS;wBAChB,kBAAkB,QAAQ,oBAAoB;oBAElD;gBACJ;gBAEA,OAAO;YACX,EAAE,OAAO,OAAO;gBACZ,OAAO;YACX;QAEJ;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE;YACjC,IAAI,SAAS;gBACT,MAAM,QAAQ,GAAG,QAAQ,QAAQ,EAAE,gCAAgC;YACvE;YAEA,IAAI,SAAS;gBACT,QAAQ;oBAAE,GAAG,KAAK;oBAAE,cAAc,QAAQ,YAAY;gBAAC;gBACvD,MAAM,GAAG,GAAG,QAAQ,UAAU;gBAC9B,MAAM,QAAQ,GAAG,QAAQ,QAAQ,IAAI;YACzC;YACA,OAAO;QACX;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE;YAClC,IAAI,SAAS;gBACT,QAAQ,YAAY,GAAG,MAAM,YAAY;gBACzC,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;gBAC3B,QAAQ,IAAI,CAAC,cAAc,GAAG,MAAM,GAAG;YACvC,0DAA0D;YAC9D;YACA,OAAO;gBACH,GAAG,OAAO;gBACV,OAAO;YACX;QACJ;IACJ;IACA,OAAO;QACH,QAAQ;IACZ;IACA,SAAS;QACL,UAAU;IACd;IACA,QAAQ;QACJ,MAAM,SAAQ,EAAE,KAAK,EAAE;YACnB,MAAM,EAAE,QAAQ,EAAE,GAAG;YACrB,QAAQ,GAAG,CAAC;YAEZ,IAAI;gBACA,MAAM,SAAS,IAAI;gBACnB,OAAO,MAAM,CAAC,iBAAiB;gBAE/B,MAAM,MAAM,GAAG,UAAU,SAAS,OAAO,gCAAgC,EAAE,OAAO,QAAQ,IAAI;gBAC9F,uCAAmC;;gBAA+B;YAEtE,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC;YAClB;QAEJ;IACJ;AACJ;AAEA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE"}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}